"""
Метод __new__ всегда выполняется перед методом __init__.
Причина, по которой __new__ всегда выполняется перед __init__,
заключается в том, что метод __new__ является статическим методом уровня класса

cls - имеет тип type, который является метаклассом. то есть любой класс, в моём случае
Singleton - является экземпляром метакласса type. аналогично тому, что объект типа int
будет являться экземпляром класса int.

object - Базовый класс иерархии классов. При вызове он не принимает аргументов и возвращает
новый безликий экземпляр, который не имеет атрибутов экземпляра.


"""


class Singleton:
    __instance = None

    def __new__(cls, *args):
        # проверяем существует ли экземпляр класса Singleton
        if cls.__instance is None:
            # задаём экземпляр класса через базовый класс
            cls.__instance = object.__new__(cls)
        return cls.__instance

    def __init__(self, a):
        self.a = a


if __name__ == '__main__':
    s1 = Singleton(1)
    s2 = Singleton("2")

    # s2 стал ссылаться на ту же область памяти, где уже лежал s1, вместо того
    # чтобы создавать новый экземпляр
    print(id(s1))
    print(id(s2))

    # id объектов будут одинаковые, потому что при инициализации s2 произошла перезапись
    # объекта, s1.a, а s2 вовсе не создался как экземпляр
    print(id(s1.a))
    print(id(s2.a))
